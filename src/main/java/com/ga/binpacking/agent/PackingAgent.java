package com.ga.binpacking.agent;

import com.ga.binpacking.model.*;
import com.ga.binpacking.algorithm.GeneticBinPacker;

import java.util.*;

/**
 * AI Agent for executing and managing the bin packing plan
 * This agent can interpret, validate, and execute the optimized packing
 * solution
 */
public class PackingAgent {

    private final String agentName;
    private final List<String> executionLog;

    public PackingAgent(String agentName) {
        this.agentName = agentName;
        this.executionLog = new ArrayList<>();
    }

    /**
     * Execute the packing plan generated by the GA
     */
    public void executePlan(GeneticBinPacker.OptimizationResult result, Bin bin) {
        log("Agent '" + agentName + "' starting execution...");
        log("Analyzing optimized packing solution...");

        PackingSolution solution = result.getSolution();

        // Validate the solution
        log("Step 1: Validating solution feasibility...");
        boolean isValid = validateSolution(solution, bin);

        if (isValid) {
            log("✓ Solution is valid and feasible");
        } else {
            log("✗ Solution validation failed");
            return;
        }

        // Analyze the packing strategy
        log("\nStep 2: Analyzing packing strategy...");
        analyzePacking(solution);

        // Simulate execution
        log("\nStep 3: Simulating physical packing process...");
        simulatePhysicalPacking(solution);

        // Generate recommendations
        log("\nStep 4: Generating optimization recommendations...");
        generateRecommendations(solution, bin);

        log("\n✓ Plan execution complete!");
    }

    /**
     * Validate the packing solution
     */
    private boolean validateSolution(PackingSolution solution, Bin bin) {
        if (solution.getPlacements().isEmpty()) {
            log("  - No items placed in solution");
            return false;
        }

        log("  - Total placements: " + solution.getPlacements().size());
        log("  - Total wastage: " + solution.getTotalWastage() + " cubic units");
        log("  - Total value: $" + String.format("%.2f", solution.getTotalCost()));

        return true;
    }

    /**
     * Analyze the packing strategy
     */
    private void analyzePacking(PackingSolution solution) {
        Map<String, Integer> itemCounts = new HashMap<>();

        for (PackingSolution.ItemPlacement placement : solution.getPlacements()) {
            String itemId = placement.getItemId();
            itemCounts.put(itemId, itemCounts.getOrDefault(itemId, 0) + 1);
        }

        log("  Item distribution:");
        for (Map.Entry<String, Integer> entry : itemCounts.entrySet()) {
            log("    - Item " + entry.getKey() + ": " + entry.getValue() + " units");
        }
    }

    /**
     * Simulate the physical packing process
     */
    private void simulatePhysicalPacking(PackingSolution solution) {
        log("  Packing sequence:");

        int step = 1;
        for (PackingSolution.ItemPlacement placement : solution.getPlacements()) {
            if (step <= 10) { // Show first 10 steps
                log(String.format("    %2d. Place Item %s at position %s (rotation: %d)",
                        step, placement.getItemId(), placement.getPosition(), placement.getRotationCode()));
            }
            step++;
        }

        if (solution.getPlacements().size() > 10) {
            log("    ... (" + (solution.getPlacements().size() - 10) + " more items)");
        }
    }

    /**
     * Generate recommendations for improvement
     */
    private void generateRecommendations(PackingSolution solution, Bin bin) {
        double utilization = (1.0 - (double) solution.getTotalWastage() / bin.getTotalVolume()) * 100.0;

        log("  Current space utilization: " + String.format("%.2f%%", utilization));

        if (utilization < 60) {
            log("  ⚠ Recommendation: Low utilization detected. Consider:");
            log("    - Using a smaller bin size");
            log("    - Adding more items to the inventory");
            log("    - Adjusting item priorities");
        } else if (utilization < 80) {
            log("  → Recommendation: Good utilization. Minor improvements possible:");
            log("    - Fine-tune rotation strategies");
            log("    - Experiment with different packing orders");
        } else {
            log("  ✓ Excellent space utilization achieved!");
            log("    - Current packing is near-optimal");
        }
    }

    /**
     * Explain the reasoning behind the solution
     */
    public void explainSolution(GeneticBinPacker.OptimizationResult result) {
        log("\n" + "=".repeat(50));
        log("AI Agent Reasoning & Explanation");
        log("=".repeat(50));

        PackingSolution solution = result.getSolution();

        log("\nThe genetic algorithm explored multiple packing configurations");
        log("and converged on the following optimized solution:");
        log("\nKey Factors:");
        log("  1. Space Efficiency: Minimizing wasted volume");
        log("  2. Value Maximization: Prioritizing high-value items");
        log("  3. Practical Feasibility: Ensuring no overlaps");

        log("\nFitness Score: " + String.format("%.4f", solution.getFitness()));
        log("This score represents the overall quality of the packing solution,");
        log("balancing space utilization, item value, and wastage penalty.");

        log("\n" + "=".repeat(50));
    }

    /**
     * Visualize the bin in ASCII art (simplified 2D projection)
     */
    public void visualizeBin(PackingSolution solution, Bin bin) {
        log("\n" + "=".repeat(50));
        log("Bin Visualization (Top View Projection)");
        log("=".repeat(50));

        int width = bin.getWidth();
        int depth = bin.getDepth();

        // Create a 2D grid for visualization (top view)
        char[][] grid = new char[depth][width];
        for (int i = 0; i < depth; i++) {
            for (int j = 0; j < width; j++) {
                grid[i][j] = '.';
            }
        }

        // Mark placed items (simplified)
        int itemIndex = 0;
        for (PackingSolution.ItemPlacement placement : solution.getPlacements()) {
            if (itemIndex < 26) { // Use A-Z for first 26 items
                char marker = (char) ('A' + itemIndex);
                Position3D pos = placement.getPosition();
                if (pos.getZ() < depth && pos.getX() < width) {
                    grid[pos.getZ()][pos.getX()] = marker;
                }
                itemIndex++;
            }
        }

        // Print the grid
        log("  (Width: " + width + ", Depth: " + depth + ")");
        log("  " + "-".repeat(width + 2));
        for (int i = 0; i < depth; i++) {
            log("  |" + new String(grid[i]) + "|");
        }
        log("  " + "-".repeat(width + 2));
        log("\nLegend: '.' = empty space, 'A-Z' = items");
        log("=".repeat(50));
    }

    private void log(String message) {
        executionLog.add(message);
        System.out.println(message);
    }

    public List<String> getExecutionLog() {
        return executionLog;
    }
}

